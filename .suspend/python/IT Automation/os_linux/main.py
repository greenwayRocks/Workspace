'''
External modules for -> generating PDFs,
serving webpages, creating compressed files,
interacting with emails and stuffs!

Benefits of automation for -> repetitive tasks,
analyzing text, generating reports, and a lot more!

AUTOMATION 'allows' IT infrastructure to SCALE! (scaliblity)

Onboarding new employees includes tasks like ->
creating a user account, a mailbox, a home folder and shared folders,
setting up approp. permissions to control access to systems & resources.
'''

# Pareto Principle
# -> 20% of sysadmin tasks makes up 80% of your work, so automate them
# -> for productivity in the long run.

# If underlying systems change and the automation is not updated accordingly
# workflows can break, CAUTION! (Bit-rot)

# It's important to think about how your automation handles ERRORS.
# We SET AND FORGET the automations, but if an automated system FAILS
# and goes unnoticed, CONSEQUENCES == 'really ' + 'bad'.upper()

# Disk backups can fail because disk identifiers can change sometimes!
# SOLUTION -> Build a method of notification into automated systems.

# NOTIFICATION methods -> (It MUST AIR)
# email
# a new entry in the internal issue tracker(make one!)
# an update to the dashboard


'''
But what if AUTOMATION succeeds with an exit status of '0' but performs the wrong action?
  Like backing up the wrong DATA? and failing to restore the required ONE later? Surprise **!

  SOLUTION: You could always use PERIODIC TESTS to check the behavior of your automated systems!
  In the backup example, we could schedule a regular restore of data backed up and compare it
  against the master data set! Maybe automate THESE REGULAR RESTORES? Are you kidding,
  NO AUTOMATION NOMORE...

  Seriously, consider an EXTRA automation for scheduled data restores for those automated backup
  systems to compare and verify the data otherwise NOTIFY me ASAP!
  BTW don't use disk labels nor anything, disk UUIDS should do the JOB!
'''

# Automated systems should log the actions it performs for easier DEBUGGING.
# Those system logs can be of FORENSIC value!
# Our scripts can be configured to write to system log.


# -------------------------------------------------------------------------------------------------- #
'''
  Example - Automation Script ( Check HEALTH of your PC )
    CHECKS ==> Disk space avail, processor overload, latest security updates, running supposed services.
              (shutil.disk_usage) (psutil.cpu_percent)

  Another e.g. Automate to detect dangerously high CPU levels and scale back the CPU clock
    speeds of those devices or shut them down for GOOD!
'''

# Check out Real Python(Dbader), Corey Schafer tutorials!

# Add an analog Internet of Things (IoT) module to each machine, in order to detect their power states,
# and write a script that records uptime and downtime, reporting hourly
# FROM QUIZ
'''
# Construct forward difference table if

For x = 10, y = 1.1
For x = 20, y = 2
For x = 30, y = 4.4
For x = 40, y = 7.9

# Construct the table of backward differences of the function f(x) = x^3 - 3 * x^2 - 5x - 7
for x = -1, 0, 1, 2, 3, 4, 5
'''


# -----------------------------------------------------------------------------------------------------------------------#
'''
<<<--- Moving to WEEK TWO (FILES) --->>>

File object has an attribute called 'FILE DESCRIPTOR' which is a token generated by the OS to do stuffs with that file!
    Each time readline() is called, the file object updates the current position in the file!
    read() method reads from the current position until the EOF. 
    readlines() returns a list of lines with a '\n' appended in each.

For large files, read line by line!
While in writing mode, you can't just read it!

File Operations:
----------------
>> os.remove(path) ;; os.rename(old_path, new_path) ;;
Use os.path.exists(path) to ->
                    check if file exists before reading or modifying,
                    ensure file does not exist before OVERWRITING.
<< Get File Size: os.path.getsize() returns in bytes.
<< File Last Modified: os.path.getmtime() returns a UNIX TimeSTAMP(since 1st January 1970).
   Use datetime.datetime.fromtimestamp() for conversion!
<< os.path.isfile() and os.path.isdir()
<< os.path.abspath(rel_path) to construct full path according to pwd.

Directories Operations:
-----------------------
>> os.getcwd() for PWD.

<< os.mkdir('new_dir')
<< os.chdir('new_dir')
<< os.rmdir() for empty dirs.
<< os.listdir()

>>> for name in os.listdir(dir):
        fullname = os.path.join(dir, name)
        if os.path.isdir(fullname):
          print('{} is a directory'.format(fullname))
        else:
          print('{} is a file'.format(fullname))

---------------------------------------------------------
# Working with CSV files
- Use CSVs to convert output of a command into a format that is easy to parse later on.
- csv.reader() and csv.writer() -> writerow() and writerows()
  >> csv.DictReader() is AMAZING!
  << csv.DictWriter() is even INCREDIBLE!

'''
